#
# Geins Management API
#  Geins Management API is an RESTful api to power your applications who manages your geins services. Geins provides an easy-to-use and scalable solution for managing all aspects of an online store, from product listings and customer information to order processing and payment transactions.   :::tip With this API, you can build custom applications and integrate with third-party systems, dashboards and other bussiness logic apps. :::    ## Getting started Once you have created an account, you can start using the Management API by creating an `API key`. You can create as many API keys as you need. Each `API key` is connected to a specific account so you can keep track of operations and manage keys. You can find your `API key` in the `geins merchant center`.   ### Fast track Use one of our [SDKs](https://docs.geins.io/docs/sdk/introduction) to get started quickly. The SDKs are available for the most popular programming languages and frameworks.  Or, if you prefer to just take it for a test run:  [![Run in Postman](https://run.pstmn.io/button.svg)](https://god.gw.postman.com/run-collection/25895885-aaf6598f-1a7c-4949-85d7-ba846c42d553?action=collection%2Ffork&collection-url=entityId%3D25895885-aaf6598f-1a7c-4949-85d7-ba846c42d553%26entityType%3Dcollection%26workspaceId%3Da2a179ce-158e-46b0-8d06-e9640f45112c)  ### Authentication Two authentication methods are supported:   - `API Key`   - `Basic Auth` 
# Version: v1.7
# Generated by OpenAPI Generator: https://openapi-generator.tech
#

<#
.SYNOPSIS

Adds a product to an existing group

.DESCRIPTION

No description available.

.PARAMETER GroupId
The ID of the group to which a product should be added

.PARAMETER ProductId
The ID of the product to be added to the target group.

.PARAMETER Variant
The variant details.

.PARAMETER ProductIdType
The type of product id provided.

.PARAMETER Include
Comma separated list of product child collections to also include with the variant group. Set to ""product"" to only include basic product data and to null (skip) to not include any product data. See  {Product.Models.ProductIncludes} names for valid options.

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

EnvelopeVariantModelsReadVariantGroup
#>
function Add-ProductToVariantGroup {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [Int32]
        ${GroupId},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${ProductId},
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [PSCustomObject[]]
        ${Variant},
        [Parameter(Position = 3, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [ValidateSet("0", "1", "2", "3")]
        [System.Nullable[Int32]]
        ${ProductIdType},
        [Parameter(Position = 4, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${Include},
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Add-ProductToVariantGroup' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded')

        $LocalVarUri = '/API/VariantGroup/{groupId}/{productId}'
        if (!$GroupId) {
            throw "Error! The required parameter `GroupId` missing when calling add_product_to_variant_group."
        }
        $LocalVarUri = $LocalVarUri.replace('{groupId}', [System.Web.HTTPUtility]::UrlEncode($GroupId))
        if (!$ProductId) {
            throw "Error! The required parameter `ProductId` missing when calling add_product_to_variant_group."
        }
        $LocalVarUri = $LocalVarUri.replace('{productId}', [System.Web.HTTPUtility]::UrlEncode($ProductId))

        if ($ProductIdType) {
            $LocalVarQueryParameters['productIdType'] = $ProductIdType
        }

        if ($Include) {
            $LocalVarQueryParameters['include'] = $Include
        }

        if (!$Variant) {
            throw "Error! The required parameter `Variant` missing when calling add_product_to_variant_group."
        }

        $LocalVarBodyParameter = $Variant | ConvertTo-Json -Depth 100

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'PUT' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "EnvelopeVariantModelsReadVariantGroup" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Adds a product to an existing group

.DESCRIPTION

No description available.

.PARAMETER ProductId1
The ID of a product belonging to the target group.

.PARAMETER ProductId2
The ID of the product to be added to the target group.

.PARAMETER ProductIdType
The type of product id provided.

.PARAMETER Include
Comma separated list of product child collections to also include with the variant group. Set to ""product"" to only include basic product data and to null (skip) to not include any product data. See  {Product.Models.ProductIncludes} names for valid options.

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

EnvelopeVariantModelsReadVariantGroup
#>
function Add-ProductToVariantGroupByProductId {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${ProductId1},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${ProductId2},
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [ValidateSet("0", "1", "2", "3")]
        [System.Nullable[Int32]]
        ${ProductIdType},
        [Parameter(Position = 3, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${Include},
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Add-ProductToVariantGroupByProductId' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        $LocalVarUri = '/API/Variant/{productId1}/{productId2}'
        if (!$ProductId1) {
            throw "Error! The required parameter `ProductId1` missing when calling add_product_to_variant_group_by_product_id."
        }
        $LocalVarUri = $LocalVarUri.replace('{productId1}', [System.Web.HTTPUtility]::UrlEncode($ProductId1))
        if (!$ProductId2) {
            throw "Error! The required parameter `ProductId2` missing when calling add_product_to_variant_group_by_product_id."
        }
        $LocalVarUri = $LocalVarUri.replace('{productId2}', [System.Web.HTTPUtility]::UrlEncode($ProductId2))

        if ($ProductIdType) {
            $LocalVarQueryParameters['productIdType'] = $ProductIdType
        }

        if ($Include) {
            $LocalVarQueryParameters['include'] = $Include
        }

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'PUT' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "EnvelopeVariantModelsReadVariantGroup" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Create a new variant group

.DESCRIPTION

No description available.

.PARAMETER VariantGroup
The settings for the new group.

.PARAMETER Include
Comma separated list of product child collections to also include with the variant group. Set to ""product"" to only include basic product data and to null (skip) to not include any product data. See  {Product.Models.ProductIncludes} names for valid options.

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

EnvelopeVariantModelsReadVariantGroup
#>
function New-VariantGroup {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [PSCustomObject]
        ${VariantGroup},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${Include},
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: New-VariantGroup' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded')

        $LocalVarUri = '/API/VariantGroup'

        if ($Include) {
            $LocalVarQueryParameters['include'] = $Include
        }

        if (!$VariantGroup) {
            throw "Error! The required parameter `VariantGroup` missing when calling create_variant_group."
        }

        $LocalVarBodyParameter = $VariantGroup | ConvertTo-Json -Depth 100

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'POST' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "EnvelopeVariantModelsReadVariantGroup" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Create a new group for the provided product id

.DESCRIPTION

No description available.

.PARAMETER ProductId
The id of the product, for which to create a group.

.PARAMETER VariantGroup
The settings for the new group.

.PARAMETER ProductIdType
The type of product id provided.

.PARAMETER Include
Comma separated list of product child collections to also include with the variant group. Set to ""product"" to only include basic product data and to null (skip) to not include any product data. See  {Product.Models.ProductIncludes} names for valid options.

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

EnvelopeVariantModelsReadVariantGroup
#>
function New-VariantGroupWithProduct {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${ProductId},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [PSCustomObject]
        ${VariantGroup},
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [ValidateSet("0", "1", "2", "3")]
        [System.Nullable[Int32]]
        ${ProductIdType},
        [Parameter(Position = 3, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${Include},
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: New-VariantGroupWithProduct' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded')

        $LocalVarUri = '/API/Variant/{productId}/VariantGroup'
        if (!$ProductId) {
            throw "Error! The required parameter `ProductId` missing when calling create_variant_group_with_product."
        }
        $LocalVarUri = $LocalVarUri.replace('{productId}', [System.Web.HTTPUtility]::UrlEncode($ProductId))

        if ($ProductIdType) {
            $LocalVarQueryParameters['productIdType'] = $ProductIdType
        }

        if ($Include) {
            $LocalVarQueryParameters['include'] = $Include
        }

        if (!$VariantGroup) {
            throw "Error! The required parameter `VariantGroup` missing when calling create_variant_group_with_product."
        }

        $LocalVarBodyParameter = $VariantGroup | ConvertTo-Json -Depth 100

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'POST' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "EnvelopeVariantModelsReadVariantGroup" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Delete an entire variant group

.DESCRIPTION

No description available.

.PARAMETER GroupId
The ID of the group to delete

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

EnvelopeVariantModelsReadVariantGroup
#>
function Invoke-DeleteVariantGroup {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [Int32]
        ${GroupId},
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-DeleteVariantGroup' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        $LocalVarUri = '/API/VariantGroup/{groupId}'
        if (!$GroupId) {
            throw "Error! The required parameter `GroupId` missing when calling delete_variant_group."
        }
        $LocalVarUri = $LocalVarUri.replace('{groupId}', [System.Web.HTTPUtility]::UrlEncode($GroupId))

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'DELETE' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "EnvelopeVariantModelsReadVariantGroup" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Delete an entire variant group

.DESCRIPTION

No description available.

.PARAMETER ProductId
The id of a product that belongs to the group to remove.

.PARAMETER ProductIdType
The type of product id provided.

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

Envelope
#>
function Invoke-DeleteVariantGroupByProductId {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${ProductId},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [ValidateSet("0", "1", "2", "3")]
        [System.Nullable[Int32]]
        ${ProductIdType},
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-DeleteVariantGroupByProductId' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        $LocalVarUri = '/API/Variant/{productId}/VariantGroup'
        if (!$ProductId) {
            throw "Error! The required parameter `ProductId` missing when calling delete_variant_group_by_product_id."
        }
        $LocalVarUri = $LocalVarUri.replace('{productId}', [System.Web.HTTPUtility]::UrlEncode($ProductId))

        if ($ProductIdType) {
            $LocalVarQueryParameters['productIdType'] = $ProductIdType
        }

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'DELETE' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "Envelope" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Get a specific variant group

.DESCRIPTION

No description available.

.PARAMETER GroupId
The ID of the group to get

.PARAMETER Include
Comma separated list of product child collections to also include with the variant group. Set to ""product"" to only include basic product data and to null (skip) to not include any product data. See  {Product.Models.ProductIncludes} names for valid options.

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

EnvelopeVariantModelsReadVariantGroup
#>
function Get-VariantGroup {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [Int32]
        ${GroupId},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${Include},
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Get-VariantGroup' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        $LocalVarUri = '/API/VariantGroup/{groupId}'
        if (!$GroupId) {
            throw "Error! The required parameter `GroupId` missing when calling get_variant_group."
        }
        $LocalVarUri = $LocalVarUri.replace('{groupId}', [System.Web.HTTPUtility]::UrlEncode($GroupId))

        if ($Include) {
            $LocalVarQueryParameters['include'] = $Include
        }

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'GET' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "EnvelopeVariantModelsReadVariantGroup" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Get the variant group for the provided id

.DESCRIPTION

No description available.

.PARAMETER ProductId
The id of the product, for which to get the group.

.PARAMETER ProductIdType
The type of id.

.PARAMETER Include
Comma separated list of product child collections to also include with the variant group. Set to ""product"" to only include basic product data and to null (skip) to not include any product data. See  {Product.Models.ProductIncludes} names for valid options.

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

EnvelopeVariantModelsReadVariantGroup
#>
function Get-VariantGroupByProductId {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${ProductId},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [ValidateSet("0", "1", "2", "3")]
        [System.Nullable[Int32]]
        ${ProductIdType},
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${Include},
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Get-VariantGroupByProductId' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        $LocalVarUri = '/API/Variant/{productId}/VariantGroup'
        if (!$ProductId) {
            throw "Error! The required parameter `ProductId` missing when calling get_variant_group_by_product_id."
        }
        $LocalVarUri = $LocalVarUri.replace('{productId}', [System.Web.HTTPUtility]::UrlEncode($ProductId))

        if ($ProductIdType) {
            $LocalVarQueryParameters['productIdType'] = $ProductIdType
        }

        if ($Include) {
            $LocalVarQueryParameters['include'] = $Include
        }

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'GET' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "EnvelopeVariantModelsReadVariantGroup" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Get all valid variant labels

.DESCRIPTION

No description available.

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

EnvelopeString
#>
function Get-VariantLabels {
    [CmdletBinding()]
    Param (
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Get-VariantLabels' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        $LocalVarUri = '/API/Variant/Labels'

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'GET' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "EnvelopeString" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Remove a product from its variant group

.DESCRIPTION

No description available.

.PARAMETER ProductId
The id of the product to remove from group.

.PARAMETER ProductIdType
The type of product id provided.

.PARAMETER Include
Comma separated list of product child collections to also include with the variant group. Set to ""product"" to only include basic product data and to null (skip) to not include any product data. See  {Product.Models.ProductIncludes} names for valid options.

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

EnvelopeVariantModelsReadVariantGroup
#>
function Remove-ProductFromVariantGroup {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${ProductId},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [ValidateSet("0", "1", "2", "3")]
        [System.Nullable[Int32]]
        ${ProductIdType},
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${Include},
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Remove-ProductFromVariantGroup' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        $LocalVarUri = '/API/Variant/{productId}'
        if (!$ProductId) {
            throw "Error! The required parameter `ProductId` missing when calling remove_product_from_variant_group."
        }
        $LocalVarUri = $LocalVarUri.replace('{productId}', [System.Web.HTTPUtility]::UrlEncode($ProductId))

        if ($ProductIdType) {
            $LocalVarQueryParameters['productIdType'] = $ProductIdType
        }

        if ($Include) {
            $LocalVarQueryParameters['include'] = $Include
        }

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'DELETE' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "EnvelopeVariantModelsReadVariantGroup" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Adds the variant details for the product with the provided ID

.DESCRIPTION

No description available.

.PARAMETER ProductId
The ID of the product for which to update the variant details.

.PARAMETER Variant
The variant details.

.PARAMETER ProductIdType
The type of product id provided.

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

EnvelopeVariantModelsReadVariant
#>
function Update-Variant {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${ProductId},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [PSCustomObject[]]
        ${Variant},
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [ValidateSet("0", "1", "2", "3")]
        [System.Nullable[Int32]]
        ${ProductIdType},
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Update-Variant' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded')

        $LocalVarUri = '/API/Variant/{productId}'
        if (!$ProductId) {
            throw "Error! The required parameter `ProductId` missing when calling update_variant."
        }
        $LocalVarUri = $LocalVarUri.replace('{productId}', [System.Web.HTTPUtility]::UrlEncode($ProductId))

        if ($ProductIdType) {
            $LocalVarQueryParameters['productIdType'] = $ProductIdType
        }

        if (!$Variant) {
            throw "Error! The required parameter `Variant` missing when calling update_variant."
        }

        $LocalVarBodyParameter = $Variant | ConvertTo-Json -Depth 100

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'PUT' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "EnvelopeVariantModelsReadVariant" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Updates the settings of a group

.DESCRIPTION

No description available.

.PARAMETER GroupId
The ID of the group to update

.PARAMETER VariantGroup
The new settings for the group

.PARAMETER Include
Comma separated list of product child collections to also include with the variant group. Set to ""product"" to only include basic product data and to null (skip) to not include any product data. See  {Product.Models.ProductIncludes} names for valid options.

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

EnvelopeVariantModelsReadVariantGroup
#>
function Update-VariantGroup {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [Int32]
        ${GroupId},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [PSCustomObject]
        ${VariantGroup},
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${Include},
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Update-VariantGroup' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded')

        $LocalVarUri = '/API/VariantGroup/{groupId}'
        if (!$GroupId) {
            throw "Error! The required parameter `GroupId` missing when calling update_variant_group."
        }
        $LocalVarUri = $LocalVarUri.replace('{groupId}', [System.Web.HTTPUtility]::UrlEncode($GroupId))

        if ($Include) {
            $LocalVarQueryParameters['include'] = $Include
        }

        if (!$VariantGroup) {
            throw "Error! The required parameter `VariantGroup` missing when calling update_variant_group."
        }

        $LocalVarBodyParameter = $VariantGroup | ConvertTo-Json -Depth 100

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'PUT' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "EnvelopeVariantModelsReadVariantGroup" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

