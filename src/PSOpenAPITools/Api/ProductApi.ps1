#
# Geins Management API
#  Geins Management API is an RESTful api to power your applications who manages your geins services. Geins provides an easy-to-use and scalable solution for managing all aspects of an online store, from product listings and customer information to order processing and payment transactions.   :::tip With this API, you can build custom applications and integrate with third-party systems, dashboards and other bussiness logic apps. :::    ## Getting started Once you have created an account, you can start using the Management API by creating an `API key`. You can create as many API keys as you need. Each `API key` is connected to a specific account so you can keep track of operations and manage keys. You can find your `API key` in the `geins merchant center`.   ### Fast track Use one of our [SDKs](https://docs.geins.io/docs/sdk/introduction) to get started quickly. The SDKs are available for the most popular programming languages and frameworks.  Or, if you prefer to just take it for a test run:  [![Run in Postman](https://run.pstmn.io/button.svg)](https://god.gw.postman.com/run-collection/25895885-aaf6598f-1a7c-4949-85d7-ba846c42d553?action=collection%2Ffork&collection-url=entityId%3D25895885-aaf6598f-1a7c-4949-85d7-ba846c42d553%26entityType%3Dcollection%26workspaceId%3Da2a179ce-158e-46b0-8d06-e9640f45112c)  ### Authentication Two authentication methods are supported:   - `API Key`   - `Basic Auth` 
# Version: v1.7
# Generated by OpenAPI Generator: https://openapi-generator.tech
#

<#
.SYNOPSIS

Adds an image relation to a product

.DESCRIPTION

No description available.

.PARAMETER ProductId
The id of the product to update.

.PARAMETER ImageName
The name of the image to set to product.

.PARAMETER IsPrimaryImage
Specifies whether {imageName} should be set as the primary image of the product.

.PARAMETER ProductIdType
The type of product id supplied in {productId}.

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

Envelope
#>
function Add-ImageToProduct {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${ProductId},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${ImageName},
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [System.Nullable[Boolean]]
        ${IsPrimaryImage},
        [Parameter(Position = 3, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [ValidateSet("0", "1", "2", "3")]
        [System.Nullable[Int32]]
        ${ProductIdType},
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Add-ImageToProduct' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        $LocalVarUri = '/API/Product/{productId}/Image/{imageName}'
        if (!$ProductId) {
            throw "Error! The required parameter `ProductId` missing when calling add_Image_to_Product."
        }
        $LocalVarUri = $LocalVarUri.replace('{productId}', [System.Web.HTTPUtility]::UrlEncode($ProductId))
        if (!$ImageName) {
            throw "Error! The required parameter `ImageName` missing when calling add_Image_to_Product."
        }
        $LocalVarUri = $LocalVarUri.replace('{imageName}', [System.Web.HTTPUtility]::UrlEncode($ImageName))

        if ($IsPrimaryImage) {
            $LocalVarQueryParameters['isPrimaryImage'] = $IsPrimaryImage
        }

        if ($ProductIdType) {
            $LocalVarQueryParameters['productIdType'] = $ProductIdType
        }

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'PUT' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "Envelope" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Add a product availability monitor

.DESCRIPTION

No description available.

.PARAMETER Model
No description available.

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

Envelope
#>
function Add-AvailabilityMonitor {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [PSCustomObject]
        ${Model},
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Add-AvailabilityMonitor' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded')

        $LocalVarUri = '/API/Product/MonitorAvailability'

        if (!$Model) {
            throw "Error! The required parameter `Model` missing when calling add_availability_monitor."
        }

        $LocalVarBodyParameter = $Model | ConvertTo-Json -Depth 100

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'POST' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "Envelope" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Adds a category relation to a product

.DESCRIPTION

No description available.

.PARAMETER ProductId
The id of the product to update.

.PARAMETER ProductCategory
The category to relate the product to.

.PARAMETER ProductIdType
The type of product id supplied in {productId}.

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

Envelope
#>
function Add-CategoryToProduct {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${ProductId},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [PSCustomObject]
        ${ProductCategory},
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [ValidateSet("0", "1", "2", "3")]
        [System.Nullable[Int32]]
        ${ProductIdType},
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Add-CategoryToProduct' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded')

        $LocalVarUri = '/API/Product/{productId}/Category'
        if (!$ProductId) {
            throw "Error! The required parameter `ProductId` missing when calling add_category_to_product."
        }
        $LocalVarUri = $LocalVarUri.replace('{productId}', [System.Web.HTTPUtility]::UrlEncode($ProductId))

        if ($ProductIdType) {
            $LocalVarQueryParameters['productIdType'] = $ProductIdType
        }

        if (!$ProductCategory) {
            throw "Error! The required parameter `ProductCategory` missing when calling add_category_to_product."
        }

        $LocalVarBodyParameter = $ProductCategory | ConvertTo-Json -Depth 100

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'PUT' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "Envelope" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Add related products to a product

.DESCRIPTION

No description available.

.PARAMETER ProductId
The id of the main product to which the relations will be created

.PARAMETER RelatedProducts
The list of related products to link with the main product.

.PARAMETER ProductIdType
The type of product id for {productId} and supplied in {relatedProducts}.

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

ProductModelsRelatedProductEnvelope
#>
function Add-RelatedProductsToProduct {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${ProductId},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [PSCustomObject[]]
        ${RelatedProducts},
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [ValidateSet("0", "1", "2", "3")]
        [System.Nullable[Int32]]
        ${ProductIdType},
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Add-RelatedProductsToProduct' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded')

        $LocalVarUri = '/API/Product/{productId}/Related'
        if (!$ProductId) {
            throw "Error! The required parameter `ProductId` missing when calling add_related_products_to_product."
        }
        $LocalVarUri = $LocalVarUri.replace('{productId}', [System.Web.HTTPUtility]::UrlEncode($ProductId))

        if ($ProductIdType) {
            $LocalVarQueryParameters['productIdType'] = $ProductIdType
        }

        if (!$RelatedProducts) {
            throw "Error! The required parameter `RelatedProducts` missing when calling add_related_products_to_product."
        }

        $LocalVarBodyParameter = $RelatedProducts | ConvertTo-Json -Depth 100

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'PUT' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "ProductModelsRelatedProductEnvelope" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Updates product items in batch

.DESCRIPTION

No description available.

.PARAMETER ProductItems
The product items to update

.PARAMETER ProductItemIdType
The type of product item id

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

Envelope
#>
function Invoke-BatchUpdateProductItems {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [PSCustomObject[]]
        ${ProductItems},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [ValidateSet("0", "1", "2", "3", "4")]
        [System.Nullable[Int32]]
        ${ProductItemIdType},
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-BatchUpdateProductItems' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded')

        $LocalVarUri = '/API/Product/Items'

        if ($ProductItemIdType) {
            $LocalVarQueryParameters['productItemIdType'] = $ProductItemIdType
        }

        if (!$ProductItems) {
            throw "Error! The required parameter `ProductItems` missing when calling batch_update_product_items."
        }

        $LocalVarBodyParameter = $ProductItems | ConvertTo-Json -Depth 100

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'PUT' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "Envelope" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Update stock values for multiple product items

.DESCRIPTION

No description available.

.PARAMETER ProductItemStocks
List of product item ids with new stock values.

.PARAMETER ProductItemIdType
The type of product item id supplied in {productItemStocks}.

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

ProductModelsStockEnvelope
#>
function Invoke-BatchUpdateStockValues {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [PSCustomObject[]]
        ${ProductItemStocks},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [ValidateSet("0", "1", "2", "3", "4")]
        [System.Nullable[Int32]]
        ${ProductItemIdType},
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-BatchUpdateStockValues' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded')

        $LocalVarUri = '/API/Product/Stock'

        if ($ProductItemIdType) {
            $LocalVarQueryParameters['productItemIdType'] = $ProductItemIdType
        }

        if (!$ProductItemStocks) {
            throw "Error! The required parameter `ProductItemStocks` missing when calling batch_update_stock_values."
        }

        $LocalVarBodyParameter = $ProductItemStocks | ConvertTo-Json -Depth 100

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'PUT' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "ProductModelsStockEnvelope" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Create a new product

.DESCRIPTION

No description available.

.PARAMETER Product
The product to create.

.PARAMETER Include
Comma separated list of child-collections to also include with the created product. See  {Product.Models.ProductIncludes} names for valid options.

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

EnvelopeProductModelsReadProduct
#>
function New-Product {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [PSCustomObject]
        ${Product},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${Include},
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: New-Product' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded')

        $LocalVarUri = '/API/Product'

        if ($Include) {
            $LocalVarQueryParameters['include'] = $Include
        }

        if (!$Product) {
            throw "Error! The required parameter `Product` missing when calling create_product."
        }

        $LocalVarBodyParameter = $Product | ConvertTo-Json -Depth 100

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'POST' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "EnvelopeProductModelsReadProduct" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Create a new product item

.DESCRIPTION

No description available.

.PARAMETER ProductId
The id of the product to create an item on.

.PARAMETER ProductItem
The product item to create.

.PARAMETER ProductIdType
The type of product id supplied in {productId}.

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

EnvelopeProductModelsReadProductItem
#>
function New-ProductItems {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${ProductId},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [PSCustomObject]
        ${ProductItem},
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [ValidateSet("0", "1", "2", "3")]
        [System.Nullable[Int32]]
        ${ProductIdType},
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: New-ProductItems' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded')

        $LocalVarUri = '/API/Product/{productId}/Item'
        if (!$ProductId) {
            throw "Error! The required parameter `ProductId` missing when calling create_product_items."
        }
        $LocalVarUri = $LocalVarUri.replace('{productId}', [System.Web.HTTPUtility]::UrlEncode($ProductId))

        if ($ProductIdType) {
            $LocalVarQueryParameters['productIdType'] = $ProductIdType
        }

        if (!$ProductItem) {
            throw "Error! The required parameter `ProductItem` missing when calling create_product_items."
        }

        $LocalVarBodyParameter = $ProductItem | ConvertTo-Json -Depth 100

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'POST' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "EnvelopeProductModelsReadProductItem" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Get a specific product

.DESCRIPTION

No description available.

.PARAMETER ProductId
The id of the product to get.

.PARAMETER ProductIdType
The type of product id supplied in {productId}.

.PARAMETER Include
Comma separated list of child-collections to also include with the requested product. See  {Product.Models.ProductIncludes} names for valid options.

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

EnvelopeProductModelsReadProduct
#>
function Get-ProductById {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${ProductId},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [ValidateSet("0", "1", "2", "3")]
        [System.Nullable[Int32]]
        ${ProductIdType},
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${Include},
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Get-ProductById' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        $LocalVarUri = '/API/Product/{productId}'
        if (!$ProductId) {
            throw "Error! The required parameter `ProductId` missing when calling get_product_by_id."
        }
        $LocalVarUri = $LocalVarUri.replace('{productId}', [System.Web.HTTPUtility]::UrlEncode($ProductId))

        if ($ProductIdType) {
            $LocalVarQueryParameters['productIdType'] = $ProductIdType
        }

        if ($Include) {
            $LocalVarQueryParameters['include'] = $Include
        }

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'GET' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "EnvelopeProductModelsReadProduct" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Get a specific product item

.DESCRIPTION

No description available.

.PARAMETER ItemId
The id of the product item to get.

.PARAMETER ProductItemIdType
The type of product item id supplied in {itemId}.

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

ProductProductItemEnvelope
#>
function Get-ProductItemById {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${ItemId},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [ValidateSet("0", "1", "2", "3", "4")]
        [System.Nullable[Int32]]
        ${ProductItemIdType},
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Get-ProductItemById' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        $LocalVarUri = '/API/Product/Item/{itemId}'
        if (!$ItemId) {
            throw "Error! The required parameter `ItemId` missing when calling get_product_item_by_id."
        }
        $LocalVarUri = $LocalVarUri.replace('{itemId}', [System.Web.HTTPUtility]::UrlEncode($ItemId))

        if ($ProductItemIdType) {
            $LocalVarQueryParameters['productItemIdType'] = $ProductItemIdType
        }

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'GET' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "ProductProductItemEnvelope" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Add related products to a product using a fixed relation type

.DESCRIPTION

No description available.

.PARAMETER ProductId
The id of the main product to which the relations will be created

.PARAMETER RelationTypeId
The relation type id that will apply to all related products in {relatedProducts}

.PARAMETER RelatedProducts
The list of related products to link with the main product.

.PARAMETER ProductIdType
The type of product id for {productId} and supplied in {relatedProducts}.

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

ProductModelsRelatedProductEnvelope
#>
function Invoke-LinkRelatedProductsByRelationId {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${ProductId},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [Int32]
        ${RelationTypeId},
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [PSCustomObject[]]
        ${RelatedProducts},
        [Parameter(Position = 3, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [ValidateSet("0", "1", "2", "3")]
        [System.Nullable[Int32]]
        ${ProductIdType},
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-LinkRelatedProductsByRelationId' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded')

        $LocalVarUri = '/API/Product/{productId}/Related/{relationTypeId}'
        if (!$ProductId) {
            throw "Error! The required parameter `ProductId` missing when calling link_related_products_by_relation_id."
        }
        $LocalVarUri = $LocalVarUri.replace('{productId}', [System.Web.HTTPUtility]::UrlEncode($ProductId))
        if (!$RelationTypeId) {
            throw "Error! The required parameter `RelationTypeId` missing when calling link_related_products_by_relation_id."
        }
        $LocalVarUri = $LocalVarUri.replace('{relationTypeId}', [System.Web.HTTPUtility]::UrlEncode($RelationTypeId))

        if ($ProductIdType) {
            $LocalVarQueryParameters['productIdType'] = $ProductIdType
        }

        if (!$RelatedProducts) {
            throw "Error! The required parameter `RelatedProducts` missing when calling link_related_products_by_relation_id."
        }

        $LocalVarBodyParameter = $RelatedProducts | ConvertTo-Json -Depth 100

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'PUT' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "ProductModelsRelatedProductEnvelope" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Get all product items with pagination

.DESCRIPTION

No description available.

.PARAMETER Page
The page to fetch

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

EnvelopeListProductModelsReadProductItem
#>
function Invoke-ListAllProductItemsPaged {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [Int32]
        ${Page},
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-ListAllProductItemsPaged' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        $LocalVarUri = '/API/Product/Items/{page}'
        if (!$Page) {
            throw "Error! The required parameter `Page` missing when calling list_all_product_items_paged."
        }
        $LocalVarUri = $LocalVarUri.replace('{page}', [System.Web.HTTPUtility]::UrlEncode($Page))

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'GET' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "EnvelopeListProductModelsReadProductItem" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Gets a list of all feeds

.DESCRIPTION

No description available.

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

EnvelopeListProductModelsReadFeed
#>
function Invoke-ListFeeds {
    [CmdletBinding()]
    Param (
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-ListFeeds' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        $LocalVarUri = '/API/Product/Feeds'

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'GET' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "EnvelopeListProductModelsReadFeed" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Get all product items

.DESCRIPTION

No description available.

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

ProductModelsReadProductItem[]
#>
function Invoke-ListProductItems {
    [CmdletBinding()]
    Param (
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-ListProductItems' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        $LocalVarUri = '/API/Product/Items'

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'GET' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "ProductModelsReadProductItem[]" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Gets a list of product relation types

.DESCRIPTION

No description available.

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

EnvelopeListProductModelsReadRelationType
#>
function Invoke-ListProductRelationTypes {
    [CmdletBinding()]
    Param (
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-ListProductRelationTypes' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        $LocalVarUri = '/API/Product/RelationTypes'

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'GET' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "EnvelopeListProductModelsReadRelationType" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Query products

.DESCRIPTION

No description available.

.PARAMETER Query
The details of the query

.PARAMETER Include
Comma separated list of child-collections to also include with the queried products. See  {Product.Models.ProductIncludes} names for valid options.

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

EnvelopeListProductModelsReadProduct
#>
function Invoke-QueryProducts {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [PSCustomObject]
        ${Query},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${Include},
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-QueryProducts' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded')

        $LocalVarUri = '/API/Product/Query'

        if ($Include) {
            $LocalVarQueryParameters['include'] = $Include
        }

        if (!$Query) {
            throw "Error! The required parameter `Query` missing when calling query_products."
        }

        $LocalVarBodyParameter = $Query | ConvertTo-Json -Depth 100

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'POST' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "EnvelopeListProductModelsReadProduct" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Query products with pagination

.DESCRIPTION

No description available.

.PARAMETER Page
The page to fetch. To start a new batched query it is mandatory to send in page=1

.PARAMETER Query
The details of the query

.PARAMETER Include
Comma separated list of child-collections to also include with the queried products. See  {Product.Models.ProductIncludes} names for valid options.

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

EnvelopeListProductModelsReadProduct
#>
function Invoke-QueryProductsPaged {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [Int32]
        ${Page},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [PSCustomObject]
        ${Query},
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${Include},
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-QueryProductsPaged' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded')

        $LocalVarUri = '/API/Product/Query/{page}'
        if (!$Page) {
            throw "Error! The required parameter `Page` missing when calling query_products_paged."
        }
        $LocalVarUri = $LocalVarUri.replace('{page}', [System.Web.HTTPUtility]::UrlEncode($Page))

        if ($Include) {
            $LocalVarQueryParameters['include'] = $Include
        }

        if (!$Query) {
            throw "Error! The required parameter `Query` missing when calling query_products_paged."
        }

        $LocalVarBodyParameter = $Query | ConvertTo-Json -Depth 100

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'POST' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "EnvelopeListProductModelsReadProduct" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Query stock

.DESCRIPTION

No description available.

.PARAMETER ProductItemIds
The details of the query.

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

ProductModelsReadProductItemStock[]
#>
function Invoke-QueryStock {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [System.Nullable[Int32][]]
        ${ProductItemIds},
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-QueryStock' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded')

        $LocalVarUri = '/API/Product/Stock/Query'

        if (!$ProductItemIds) {
            throw "Error! The required parameter `ProductItemIds` missing when calling query_stock."
        }

        $LocalVarBodyParameter = $ProductItemIds | ConvertTo-Json -Depth 100

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'POST' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "ProductModelsReadProductItemStock[]" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Updates a product

.DESCRIPTION

No description available.

.PARAMETER ProductId
The id of the product to update.

.PARAMETER Product
The product data to update.

.PARAMETER ProductIdType
The type of product id supplied in {productId}.

.PARAMETER Include
Comma separated list of child-collections to also include with the updated product. See  {Product.Models.ProductIncludes} names for valid options.

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

EnvelopeProductModelsReadProduct
#>
function Update-Product {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${ProductId},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [PSCustomObject]
        ${Product},
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [ValidateSet("0", "1", "2", "3")]
        [System.Nullable[Int32]]
        ${ProductIdType},
        [Parameter(Position = 3, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${Include},
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Update-Product' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded')

        $LocalVarUri = '/API/Product/{productId}'
        if (!$ProductId) {
            throw "Error! The required parameter `ProductId` missing when calling update_product."
        }
        $LocalVarUri = $LocalVarUri.replace('{productId}', [System.Web.HTTPUtility]::UrlEncode($ProductId))

        if ($ProductIdType) {
            $LocalVarQueryParameters['productIdType'] = $ProductIdType
        }

        if ($Include) {
            $LocalVarQueryParameters['include'] = $Include
        }

        if (!$Product) {
            throw "Error! The required parameter `Product` missing when calling update_product."
        }

        $LocalVarBodyParameter = $Product | ConvertTo-Json -Depth 100

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'PUT' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "EnvelopeProductModelsReadProduct" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Updates a product item

.DESCRIPTION

No description available.

.PARAMETER ItemId
The id of the product item to update.

.PARAMETER ProductItem
The product item data to update.

.PARAMETER ProductItemIdType
The type of product item id supplied in {itemId}.

.PARAMETER ReturnType

Select the return type (optional): application/json, text/json, application/xml, text/xml

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

EnvelopeProductModelsReadProductItem
#>
function Update-ProductItem {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${ItemId},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [PSCustomObject]
        ${ProductItem},
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [ValidateSet("0", "1", "2", "3", "4")]
        [System.Nullable[Int32]]
        ${ProductItemIdType},
        [String]
        [ValidateSet("application/json", "text/json", "application/xml", "text/xml")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Update-ProductItem' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json', 'text/json', 'application/xml', 'text/xml')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded')

        $LocalVarUri = '/API/Product/Item/{itemId}'
        if (!$ItemId) {
            throw "Error! The required parameter `ItemId` missing when calling update_product_item."
        }
        $LocalVarUri = $LocalVarUri.replace('{itemId}', [System.Web.HTTPUtility]::UrlEncode($ItemId))

        if ($ProductItemIdType) {
            $LocalVarQueryParameters['productItemIdType'] = $ProductItemIdType
        }

        if (!$ProductItem) {
            throw "Error! The required parameter `ProductItem` missing when calling update_product_item."
        }

        $LocalVarBodyParameter = $ProductItem | ConvertTo-Json -Depth 100

        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["apiKey"]) {
            $LocalVarHeaderParameters['apiKey'] = $Configuration["ApiKey"]["apiKey"]
            Write-Verbose ("Using API key 'apiKey' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        if ($Configuration["Username"] -and $Configuration["Password"]) {
            $LocalVarBytes = [System.Text.Encoding]::UTF8.GetBytes($Configuration["Username"] + ":" + $Configuration["Password"])
            $LocalVarBase64Text =[Convert]::ToBase64String($LocalVarBytes)
            $LocalVarHeaderParameters['Authorization'] = "Basic " + $LocalVarBase64Text
            Write-Verbose ("Using HTTP basic authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'PUT' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "EnvelopeProductModelsReadProductItem" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

